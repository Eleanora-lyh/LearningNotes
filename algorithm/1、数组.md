## 1、二分模板

### 1）找某数第一次/最后一次出现的下标

用二分去查找元素要求数组的有序性或者拥有类似于有序的性质，二分可以找到满足某条件的分界点，二分应用有下面这四种情况：

- 找>=数的第一个位置（满足某个条件的第一个数）
- 找<=数的最后一个数（满足某个条件的最后一个数）
- 查找最大值（满足该边界的右边界）
- 查找最小值（满足该边界的左边界）

原题链接：

​	789. 数的范围：https://www.acwing.com/problem/content/791/

此题目的是找到x第一次出现和最后一次出现的下标，x第一次出现转换为找到 >= x的第一个数，x最后一次出现转换为找到 <= x 的最后一个数 （分析如下）

![image-20240406210304376](../TyporaImgs/image-20240406210304376.png)

模板代码：

```C++
#include <iostream>
using namespace std;
const int N = 1e5 + 10;
int q[N];
//1 2 2 3 3 4
// 找左边的右边界值
int SL(int l, int r, int x) {
	while (l<r)
	{
		int mid = l + r >> 1;
		if (q[mid] >= x) r = mid;
		else l = mid + 1;
	}
	return l;
}
// 找右边的左边界值
int SR(int l, int r, int x) {
	while (l < r)
	{
		int mid = l + r +1>> 1;
		if (q[mid] <= x) l = mid;
		else r = mid - 1;
	}
	return r;
}
int main()
{
	int n, m;
	scanf("%d %d", &n, &m);
	for (int i = 0; i < n; i++) {
		scanf("%d", &q[i]);
	}
	while (m--) {
		int x;
		scanf("%d", &x);
		int l = SL(0, n - 1, x);
		if (q[l] != x) printf("-1 -1\n");
		else {
			printf("%d %d\n", l, SR(0, n - 1, x));
		}
	}
}
```

### 2）找某个数的位置

https://leetcode.cn/problems/binary-search/description/

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        while(l<=r){
            int mid = (l+r)>>1;
            if(nums[mid] > target) r = mid - 1;
            else if(nums[mid] < target) l = mid + 1;
            else return mid;
        }
        return -1;
    }
};
```

时间复杂度 O(logn) 空间复杂度O(1)

### 3）搜索插入位置

https://leetcode.cn/problems/search-insert-position/description/

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

```C++
class Solution {
public:
    int BinarySearch(vector<int>& nums, int target){
        int l = 0, r = nums.size()-1;
        while(l<=r) {
            int mid = (l+r)>>1;
            if(nums[mid]>target) r = mid - 1;
            else if(nums[mid]<target) l = mid + 1;
            else return mid;
        }
        return r + 1;
    }
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        if(target<nums[0]) return 0;
        else if(target>nums[n-1]) return n;
        else{
            return BinarySearch(nums,target);
        }
    }
};
//或
class Solution {
public:
    int BinarySearch(vector<int>& nums, int target){
        int l = 0, r = nums.size;
        while(l<r) {
            int mid = (l+r)>>1;
            if(nums[mid]>target) r = mid;
            else if(nums[mid]<target) l = mid + 1;
            else return mid;
        }
        return r + 1;
    }
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        if(target<nums[0]) return 0;
        else if(target>nums[n-1]) return n;
        else{
            return BinarySearch(nums,target);
        }
    }
};
```

时间复杂度 O(logn) 空间复杂度O(1)

解法参考文章：https://programmercarl.com/0035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC

## 2、移除元素

### 移除元素

https://leetcode.cn/problems/remove-element/description/

要注意特殊的输入：

- 当数组中只有一个元素且不存在val时，i j 都指向第一个元素，i=j=0，返回1
- 数组中只有一个元素且就为val时，i j 都指向第一个元素时，i=j=0，返回0

同时要注意移动i j 时注意不要超出边界

```C++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
		int n = nums.size(), res = 0, i = -1, j = n;
		if (n == 1) { //特判
			if (nums[0] == val) return 0;
			else return n;
		}
		while (i < j) {
			do i++; while (i <= n-1 && nums[i] != val); //跳出循环时i指向val
			do j--; while (j >= 0 && nums[j] == val); //跳出循环时j指向非val
			if (i < j) {
				swap(nums[i], nums[j]);
			}
		}
        return i;
    }
};
```

时间复杂度 O(n)

### 删除有序数组中的重复项

https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/



## 3、有序数组的平方

https://leetcode.cn/problems/squares-of-a-sorted-array/description/

暴力排序：

时间复杂度：O(n) + O(nlogn) = O(nlogn) 

```C++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size();
        for(int i = 0;i<n;i++) 
        {
            nums[i] = nums[i]*nums[i];
        }
        sort(nums.begin(), nums.end());
        return nums;
    }
};
```

双指针解法：

i j 指向数组两端，拿到平方最大的为结果集中最大的值

```C++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        int i = 0,j = n-1,k = n-1;
        while(i<=j) 
        {
            if(nums[j]*nums[j]>=nums[i]*nums[i]){
                res[k--] = nums[j]*nums[j];
                j--;
            }else{
                res[k--] = nums[i]*nums[i];
                i++;
            }
        }
        return res;
    }
};
```

## 4、滑动窗口 SideWindow



## 2、1221. 四平方和

https://www.acwing.com/file_system/file/content/whole/index/content/4184156/

在竞赛中，一般认为计算机1秒能执行 $$5 × 10^8$$ 次计算。本来，我们需要枚举 a, b, c , d四个数字，因为第四个数字可以计算出来，所以至少需要三重循环，即 $$O(n^3)$$，但是这肯定是要超时的，所以就想办法优化循环的次数

一个比较好的思路是把三重循环拆成两次二重循环。在第一次二重循环中，计算一下$$c^2+d^2$$,然后记录下来，在第二次对a和b的循环中可以直接使用，而不需要再次计算。如此一来，时间复杂度就被大大的简化了。

![image-20240408212042801](../TyporaImgs/image-20240408212042801.png)

```C++
#include<bits/stdc++.h>
using namespace std;
const int N = 5e6 + 10;

//构造一个类，存储c、d、c+d，重写<符号，先比较s，在比较c，最后比较d
struct CDSum {
	int c, d, s;
	bool operator < (const CDSum &t) const {
		if (s != t.s) return s < t.s;
		if (c != t.c) return c < t.c;
		return d < t.d;
	}
};

int n;
CDSum record[N * 2];

int main() {
	scanf("%d", &n);
	int m = 0;
	//遍历所有c、d的组合(保证d>=c)
	for (int c = 0; c * c <= n; c++) {
		for (int d = c; c * c + d * d <= n; d++) {
			record[m++] = {  c,d,c * c + d * d };
		}
	}
	//按照cd平方和从小到大排序
	sort(record, record + m);
	//根据c、d的组合遍历a、b的组合
	for (int a = 0; a * a <= n; a++) {
		for (int b = a; a * a + b * b <= n; b++) {
			int x = n - a * a - b * b; //c*c+d*d之和
			int l = 0, r = m - 1;
			while (l<r)
			{
				int mid = l + r >> 1;
				if (record[mid].s >= x) r = mid;
				else l = mid + 1;
			}
			if (record[r].s == x) {
				printf("\n%d %d %d %d", a, b, record[r].c, record[r].d);
				return 0;
			}
		}
	}
	//printf("%d %d %d %d", a,b,c,d);
	return 0;
}
```

参考文章：手动哈希的方法见链接

https://www.acwing.com/solution/content/90665/



## 3、1227. 分巧克力

https://www.acwing.com/file_system/file/content/whole/index/content/4184162/

## 4、730. 机器人跳跃问题

https://www.acwing.com/file_system/file/content/whole/index/content/4183854/

## 5、1236. 递增三元组

https://www.acwing.com/file_system/file/content/whole/index/content/4184171/

## 6、P1902 刺杀大使

https://www.luogu.com.cn/problem/P1902

## 7、P2678 [NOIP2015 提高组] 跳石头

https://www.luogu.com.cn/problem/P2678