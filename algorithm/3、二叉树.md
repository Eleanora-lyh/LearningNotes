基础信息详见
https://labuladong.online/algo/data-structure-basic/binary-tree-basic/#%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91

包括 满二叉树(Perfect Binary Tree)  每个节点都是满的

完全二叉树(Complete Binary Tree) 除最后一层都是满的

二叉搜索树(Binary Search Tree) 左<中<右 BST树的中序遍历是有序的

高度平衡二叉树(Height-Balanced Binary Tree) 每个节点都是满的

自平衡二叉树(Self-Balanced Binary Tree)

# 1、树的定义

用类定义

```C#
public class TreeNode
{
    public int val;
    public TreeNode left;
    public TreeNode right;
    public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null)
    {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

用字典定义（邻接表）

```C#
Dictionary<int, List<int>> tree = new ();
tree.Add(1, new List<int>(){2, 3});
tree.Add(2, new List<int>() { 4 });
tree.Add(3, new List<int>() { 5, 6 });
```



# 2、二叉树的遍历

DFS 算法常用来穷举所有路径，BFS 算法常用来寻找最短路径

## 2.1 递归遍历 DFS

所谓的前中后序遍历，其实就是在二叉树遍历框架的不同位置写代码：

```C#
// 二叉树的遍历框架
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // 前序位置
    traverse(root.left);
    // 中序位置
    traverse(root.right);
    // 后序位置
}
```

**前序位置的代码会在进入节点时立即执行；中序位置的代码会在左子树遍历完成后，遍历右子树之前执行；后序位置的代码会在左右子树遍历完成后执行**

## 2.2 层序遍历 BFS

最简单的写法（无法统计层数）————因为分不清队列中的是兄弟节点还是子节点

```C#
public class Solution
{
    void LevelOrderTraversal(TreeNode root)
    {
        if (root == null) return;
        Queue<TreeNode> queue = new Queue<TreeNode>();
        queue.Enqueue(root);
        int depth = 1;
        while (queue.Count != 0)
        {
            var curr = queue.Peek();
            Console.WriteLine("depth = " + depth + ", val = " + curr.val);
            TreeNode node = queue.Dequeue();
            if (node.left != null) queue.Enqueue(node.left);
            if (node.right != null) queue.Enqueue(node.right);
        }
    }
}
```



可记录层数（**每条树枝的权重是 1**）———— 放入左右节点前记录size，size范围内为同一层，遍历后depth++

```C#
public class Solution 
{
   void LevelOrderTraversal(TreeNode root)
   {
       if (root == null) return;
       Queue<TreeNode> queue = new Queue<TreeNode>();
       queue.Enqueue(root);
       int depth = 1;
       while (queue.Count != 0)
       {   
            int size = queue.Count;
            for (int i = 0; i < size; i++)
            {
                var curr = queue.Peek();
                Console.WriteLine("depth = " + depth + ", val = " + curr.val);
                TreeNode node = queue.Dequeue();
                if (node.left != null) queue.Enqueue(node.left);
                if (node.right != null) queue.Enqueue(node.right);
            }
            depth++;
        }
    }
}
public class TreeNode
{
    public int val;
    public TreeNode left;
    public TreeNode right;
    public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null)
    {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

可记录权重（**每条树枝的权重不是 1**）———— 入队时深度权重就被存储在 `State` 对象中，所以无需统计当前层的个数

```C#
public class Solution 
{
   void LevelOrderTraversal(TreeNode root)
   {
       if (root == null) return;
       Queue<State> queue = new Queue<State>();
       queue.Enqueue(new State(root, 1));
       while (queue.Count != 0)
       {
            var curr = queue.Dequeue();
            Console.WriteLine("depth = " + curr.depth + ", val = " + curr.node.val);
            
            if (curr.node.left != null) 
                queue.Enqueue(new State(curr.node.left, curr.depth + 1));
            if (curr.node.right != null) 
                queue.Enqueue(new State(curr.node.right, curr.depth + 1));
       }
   }
}

public class State
{
    public TreeNode node;
    public int depth;

    public State(TreeNode node, int depth)
    {
        this.node = node;
        this.depth = depth;
    }
}
public class TreeNode
{
    public int val;
    public TreeNode left;
    public TreeNode right;
    public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null)
    {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

# 3、多叉树的遍历 25-7.21

二叉树的节点

```C#
public class TreeNode
{
    public int val;
    public TreeNode left;
    public TreeNode right;
}
```

多叉树的节点

```C#
public class TreeNode
{
    public int val;
    public List<TreeNode> children;
}
```

二叉树是特殊的多叉树。**森林就是多个多叉树的集合（一棵多叉树是一个特殊的森林）**

只需对每个根节点分别进行 DFS/BFS 遍历，即可遍历森林的所有节点。

## 3.1 递归遍历

```C#
// 二叉树的遍历框架
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // 前序位置
    traverse(root.left);
    // 中序位置
    traverse(root.right);
    // 后序位置
}

void traverse(Node root)
{
    if (root == null)
    {
        return;
    }
    // 前序位置
    foreach (Node child in root.children)
    {
        traverse(child);
    }
    // 后序位置
}
```

## 3.2 层序遍历

无非就是把二叉树的左右子节点换成了多叉树的所有子节点。所以多叉树的层序遍历也有三种写法

最简单的写法（无法统计层数）————因为分不清队列中的是兄弟节点还是子节点

```C#
public class Solution
{
    void levelOrderTraverse(TreeNode root)
    {
        if (root == null)
        {
            return;
        }

        Queue<TreeNode> queue = new Queue<TreeNode>();
        queue.Enqueue(root);
        while(queue.Count > 0)
        {
            TreeNode node = queue.Dequeue();
            Console.WriteLine(node.val);
            foreach (var child in node.children)
            {
                queue.Enqueue(child);
            }
        }
    }
}
```



可记录层数（**每条树枝的权重是 1**）———— 放入左右节点前记录size，size范围内为同一层，遍历后depth++

```C#
public class Solution
{
    void levelOrderTraverse(TreeNode root)
    {
        if (root == null)
        {
            return;
        }
        int depth = 1;
        Queue<TreeNode> queue = new Queue<TreeNode>();
        queue.Enqueue(root);
        while(queue.Count > 0)
        {
            int size = queue.Count;
            for (int i = 0; i < size - 1; i++)
            {
                TreeNode node = queue.Dequeue();
                Console.WriteLine(node.val);
                foreach (var child in node.children)
                {
                    queue.Enqueue(child);
                }
            }
            depth++;
        }
    }
}
```

可记录权重（**每条树枝的权重不是 1**）———— 入队时深度权重就被存储在 `State` 对象中，所以无需统计当前层的个数

```C#
public class Solution
{
    void levelOrderTraverse(TreeNode root)
    {
        if (root == null)
        {
            return;
        }
        Queue<State> queue = new Queue<State>();
        queue.Enqueue(new State(root,1));
        while(queue.Count > 0)
        {
            State stateNode = queue.Dequeue();
            TreeNode cur = stateNode.node;
            var depth = stateNode.depth;
            Console.WriteLine("depth = " + depth + ", val = " + cur.val);
            foreach (var child in cur.children)
            {
                queue.Enqueue(new State(child, depth+1));
            }
        }
    }
}
class State
{
    public TreeNode node;
    public int depth;

    public State(TreeNode node, int depth)
    {
        this.node = node;
        this.depth = depth;
    }
}
public class TreeNode
{
    public int val;
    public List<TreeNode> children;
}
```

## 4、 习题

利用后序位置的题目，一般都使用「分解问题」的思路。因为当前节点接收并利用了子树返回的信息，这就意味着你把原问题分解成了当前节点 + 左右子树的子问题。



二叉树解题的思维模式分两类：

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

## 4.1 思路

### 111. 二叉树的最小深度 25-7.20

https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：2
```

**示例 2：**

```
输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
```

 BFS找到结果即返回，同一层中只要有一个节点的左右节点为空，则更新结果

```C#
public class Solution
{
    public int MinDepth(TreeNode root)
    {
        if (root == null) return 0;
        Queue<TreeNode> queue = new Queue<TreeNode>();
        queue.Enqueue(root);
        int depth = 1;
        while(queue.Count > 0)
        {
            int size = queue.Count;
            
            for (int i = 0; i < size; i++)
            {
                TreeNode cur = queue.Dequeue();
                if (cur.left == null && cur.right == null)
                    return depth;
               
                if (cur.left != null) queue.Enqueue(cur.left);
                if (cur.right != null) queue.Enqueue(cur.right);
                
            }
            Console.WriteLine();
            depth++;
            
        }
        return depth;
    }
}
```

DFS更新结果则需要找到所有的解后通过更新res才能找到最小姐，需要注意的是当一个节点的左右节点都为null时的深度才是结果，如果按照节点为null来更新res则会错误计算（如单边二叉树）

```C#
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution
{
    public int minDepth = int.MaxValue;
    public int currDepth = 0;
    public int MinDepth(TreeNode root)
    {
        DFS(root);
        return minDepth;
    }
    public void DFS(TreeNode root)
    {
        if (root == null) return;
        
        currDepth++;
        if (root.left == null && root.right == null)
        {
            minDepth = Math.Min(minDepth, currDepth);
        }
        DFS(root.left);
        DFS(root.right);
        currDepth--;
    }
}
```

### 104. 二叉树的最大深度 25-17.21

https://leetcode.cn/problems/maximum-depth-of-binary-tree/

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

 

```
输入：root = [3,9,20,null,null,15,7]
输出：3
```

**示例 2：**

```
输入：root = [1,null,2]
输出：2
```

2025.7.21 同最小深度，用DFS遍历所有解后更新res即可，如果遍历完左右节点后没有更新currDepth --;会导致maxDepth的更新有问题。

```C#
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution {
    public int maxDepth = int.MinValue;
    public int currDepth = 0;
    public int MaxDepth(TreeNode root) {
        if(root == null) return 0;
        traverse(root);
        return maxDepth;
    }
    public void traverse(TreeNode root){
        if(root == null){
            return ;
        }
        currDepth ++;
        if(root.left == null && root.right == null){
            maxDepth = Math.Max(maxDepth,currDepth);
        }
        traverse(root.left);
        traverse(root.right);
        currDepth --;
    }
}
```

### 144. 二叉树的前序遍历  25-17.21

https://leetcode.cn/problems/binary-tree-preorder-traversal/

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

```C#
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution {
    public List<int> res = new List<int>();
    public IList<int> PreorderTraversal(TreeNode root) {
        traverse(root);
        return res;
    }
    public void traverse(TreeNode root){
        if(root == null) return ;
        res.Add(root.val);
        traverse(root.left);
        traverse(root.right);
    }
}
```

### 543. 二叉树的直径 25-17.22

https://leetcode.cn/problems/diameter-of-binary-tree/

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)

```
输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

**示例 2：**

```
输入：root = [1,2]
输出：1
```

2025.7.21 我想的是求root的左边最长 + root右边最长即为结果（接近最终结果但是还是不对）应该是一个节点的左边长度+右边长度和最大

1、是否可以通过遍历一遍二叉树得到答案？———— 不可以

2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？———— 可以 任意两个节点之间最长路径=节点（左边长度+右边长度）最大值

3、二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做？ ———— 每个节点获取左边的长度，右边的长度；利用二叉树后序遍历的性质，后序的位置可以获取左子树和右子树的信息，所以更新最大长度放在最后

```C#
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution {
    public int maxDiameter = 0;
    public int DiameterOfBinaryTree(TreeNode root) {
        maxDepth(root);
        return maxDiameter;
    }
    public int maxDepth(TreeNode root){
        if(root == null) return 0;
        int lDepth = maxDepth(root.left);
        int rDepth = maxDepth(root.right);
        maxDiameter = Math.Max(maxDiameter,lDepth+rDepth);
        return Math.Max(lDepth,rDepth) + 1;
    }
}
```

### 二叉树的节点数 25-7.22

1、是否可以通过遍历一遍二叉树得到答案？

———— 不可以

2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？

———— 可以 res = `root左子树节点数 + root左子树节点数` 

3、二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做？

———— 每个节点获取左边的长度，右边的长度；利用二叉树后序遍历的性质，后序的位置可以获取左子树和右子树的信息，所以更新节点数放在最后

```C#
public class Solution
{
    int CountNode(Node root)
    {
        if(root == null) return 0; 
        int lNodes = CountNode(root.left);
        int rNodes = CountNode(root.right);
        return lNodes + rNodes + 1;
    }
}
public class Node
{
    public int val;
    public Node left;
    public Node right;
}
```

### 226. 翻转二叉树 25-7.22

https://leetcode.cn/problems/invert-binary-tree/

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```

**1、是否可以通过遍历一遍二叉树得到答案**？

不可以

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？

可以，翻转整个二叉树 = 翻转每个节点的左右子树

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？

左右节点只互换，在前序位置做

```C#
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution {
    public TreeNode InvertTree(TreeNode root) {
        ReverseTree(root);
        return root;
    }
    public void ReverseTree(TreeNode root){
        if(root == null) return ;
        var tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        ReverseTree(root.left);
        ReverseTree(root.right);
    }
}
```

### 116. 填充每个节点的下一个右侧节点指针 25-7.22

https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)

```
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
```

**示例 2:**

```
输入：root = []
输出：[]
```

2025.7.22 我的解法是通过非递归遍历将一层的节点取出来，同层的最后一个节点的next为null

**1、是否可以通过遍历一遍二叉树得到答案**？

可以，将同一层的节点放入一个Queue中，同层的最后一个节点的next为null

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？

不可以，整个二叉树的next指针 = 每个节点的左子树指向右子树，右子树指向null（这样想有问题5->6无法连接）

**3、如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？

// 每个节点的左子树指向右子树，右子树指向null，在前序位置做

```C#
/*
// Definition for a Node.
public class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
}
*/

public class Solution
{
    public Node Connect(Node root)
    {
        if (root == null) return null;
        Queue<Node> queue = new();
        queue.Enqueue(root);
        while (queue.Count() > 0)
        {
            int size = queue.Count;
            for (int i = 0; i < size; i++)
            {
                var node = queue.Dequeue();
                node.next = (i == size - 1) ? null : queue.Peek();
                if (node.left != null) queue.Enqueue(node.left);
                if (node.right != null) queue.Enqueue(node.right);
            }
        }
        return root;
    }
}
```

2025.7.23 思考能不能通过递归的写法完成

填充整个子树的next = 填充每个节点的（左节点 + 右节点） 左节点指向右节点，右节点指向null；但是这里无法解决左右子树的孙子节点的连接，如（5->6）。

看了题解发现新思路，可以将框内的两个节点当作一个节点，这样完美二叉树变成了一个三叉树，子问题为将合并节点内部的元素相连。

![image-20250723194147628](./imgs/3、二叉树/image-20250723194147628.png)

最终解法如下

```C#
public class Solution
{
    public Node Connect(Node root)
    {
        if (root == null) return null;
        SetNextPointer(root.left, root.right);
        return root;
    }
    public void SetNextPointer(Node leftNode, Node rightNode)
    {
        if(leftNode == null || rightNode == null)
        {
            return;
        }
        leftNode.next = rightNode;
        rightNode.next = null;
        SetNextPointer(leftNode.left, leftNode.right);
        SetNextPointer(leftNode.right, rightNode.left);
        SetNextPointer(rightNode.left, rightNode.right);
    }
}
```

### 114. 二叉树展开为链表 25-7.23

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [0]
输出：[0]
```

2025.7.23 根本没想出来，看了题解，通过遍历（BFS、DFS）无法解决

对于一个节点 `x`，可以执行以下流程：

1、先利用 `flatten(x.left)` 和 `flatten(x.right)` 将 `x` 的左右子树拉平。

2、将 `x` 的右子树接到左子树下方，然后将整个左子树作为右子树。

```C#
public class Solution
{
    public void Flatten(TreeNode root)
    {
        if (root == null) return;

        Flatten(root.left);
        Flatten(root.right);
        // already flatten, imagin 3 node like a trangle
        var tmpLeft = root.left;
        var tmpRight = root.right;
        // make left node in the right
        root.left = null;
        root.right = tmpLeft;
        // find the last right node
        TreeNode p = root;
        while (p.right != null)
        {
            p = p.right;
        }
        //last right node's right is tmpRight
        p.right = tmpRight;
    }
}
```

## 4.2 构造



# 

# Count VS Any

|     **特性**     |          `queue.Count != 0`          |            `queue.Any()`             |
| :--------------: | :----------------------------------: | :----------------------------------: |
|  **时间复杂度**  | O(1)（`ICollection`） / O(n)（其他） |      O(1)（非空） / O(n)（空）       |
| **适用集合类型** |    明确实现 `ICollection` 的集合     |  所有 `IEnumerable`（包括流式数据）  |
|     **语义**     |          “元素数量是否为0”           |          “是否存在任何元素”          |
|   **线程安全**   |        需额外同步机制（如锁）        |            需额外同步机制            |
|   **推荐场景**   |        高频检查、需获取数量时        | 未知集合类型、数据库查询、大型数据流 |