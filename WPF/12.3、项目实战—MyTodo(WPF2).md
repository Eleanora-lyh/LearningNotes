

由于在wpf项目中需要使用到分页返回类型和Dto，所以这里需要：

1）将webapi项目的UnitOfWork文件夹中的`IPagedList和PagedList`移动到MyTodo.Shared项目的Collections文件夹（需要修改webapi中的引用，IPagedList中部分方法改为public）

2）将MyTodo项目Common.Models文件夹中的Dto注释掉，引用MyTodo.Shared项目Dtos文件夹中的Dto类

MemoDto

```C#
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MyTodo.Shared.Dtos
{
    /// <summary>
    /// 备忘录事项Dto
    /// </summary>
    public class MemoDto : BaseDto
    {
        private string title;
        private string content;
        private int status;

        public string Title
        {
            get { return title; }
            set
            { title = value; OnPropertyChanged(); }
        }

        public string Content
        {
            get { return content; }
            set
            { content = value; OnPropertyChanged(); }
        }
        /// <summary>
        /// 当前状态
        /// </summary>
        public int Status
        {
            get { return status; }
            set { status = value; OnPropertyChanged(); }
        }
    }
}
```

TodoDto

```C#
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MyTodo.Shared.Dtos
{
    /// <summary>
    /// 待办事项Dto
    /// </summary>
    public class TodoDto : BaseDto
    {
        private string title;
        private string content;
        private int status;

        public string Title
        {
            get { return title; }
            set { title = value; OnPropertyChanged(); }
        }

        public string Content
        {
            get { return content; }
            set { content = value; OnPropertyChanged(); }

        }

        public int Status
        {
            get { return status; }
            set { status = value; OnPropertyChanged(); }
        }
    }
}
```

BaseDto

```C#
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace MyTodo.Shared.Dtos
{
    public class BaseDto : INotifyPropertyChanged
    {
        public int Id { get; set; }
        public event PropertyChangedEventHandler? PropertyChanged;
        /// <summary>
        /// 实现通知更新
        /// </summary>
        /// <param name="propertyName"></param>
        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        protected bool SetField<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
        {
            if (EqualityComparer<T>.Default.Equals(field, value)) return false;
            field = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }
}
```

## 1、让WPF发起Http请求

### 1）RestSharp简介

在完成webapi代码后，使用apipost可以测试接口，点击生成代码可以看到apipost是如何发起请求的：

![image-20240609224738280](../TyporaImgs/image-20240609224738280.png)

对于C#来说，有两种方式可以发起http请求：HttpClient和RestSharp，二者的区别如下：

RestSharp:

- RestSharp 是一个用于 .NET 的轻量级 REST 客户端库。它可以很方便地发起 REST 请求,摒弃了许多 HTTP 细节,让开发变得简单明了。
- 使用 RestSharp 时,我们只需定义一个请求对象,然后执行它。RestSharp 会自动处理请求参数的序列化和响应的反序列化。
- 它还内置了JSON和XML格式的支持,状态码检查,认证机制等实用功能。

HttpClient:

- HttpClient 是 .NET 中微软推荐的通用 HTTP 客户端库。它提供了灵活的同步和异步 HTTP 请求接口。
- 相比 RestSharp,HttpClient 并没有那么多封装,我们需要自己构建请求并处理响应等Details。但它本身更轻量级。
- 关键优点包括支持同步和异步调用、请求对象可以复用、自动处理HTTP消息等。

总的来说:

- RestSharp 对常见的CRUD请求更友好简单
- HttpClient 给了我们更多控制能力,但代码复杂度也相对更高

### 2）构造通用的HttpRestClient执行方法

添加RestSharp依赖包

```bash
NuGet\Install-Package RestSharp -Version 111.2.0
```

RestSharp的使用文档：https://restsharp.dev/docs/usage/

Service文件夹下添加HttpRestClient类

```C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MyTodo.Shared;
using Newtonsoft.Json;
using RestSharp;

namespace MyTodo.Service
{
    public class HttpRestClient
    {
        private readonly string _apiUrl;
        private readonly RestClient _client;
        public HttpRestClient(string apiUrl)
        {
            _apiUrl = apiUrl; //依赖注入apiUrl= http://localhost:7147/
            //使用_apiUrl构造RestClient实例
            _client = new RestClient(new RestClientOptions(_apiUrl)) ;
        }
        /// <summary>
        /// 非泛型执行请求
        /// </summary>
        /// <param name="baseRequest"></param>
        /// <returns></returns>
        public async Task<ApiResponse> ExecuteAsync(BaseRequest baseRequest)
        {
            //初始化请求，标记请求类型
            var request = new RestRequest(baseRequest.Route,baseRequest.Method);
            //添加请求头
            request.AddHeader("Content-Type", baseRequest.ContentType);
            if (baseRequest.Parameter != null)
            {
                //添加请求参数
                request.AddParameter("param", JsonConvert.SerializeObject(baseRequest.Parameter), ParameterType.RequestBody);
            }
            //获取请求返回值
            var response = await _client.ExecuteAsync(request);
            var res = JsonConvert.DeserializeObject<ApiResponse>(response.Content);
            return res;
        }
        public async Task<ApiResponse<T>> ExecuteAsync<T>(BaseRequest baseRequest)
        {
            //初始化请求的方法名，标记请求类型
            var request = new RestRequest(baseRequest.Route, baseRequest.Method);
            //添加请求头
            request.AddHeader("Content-Type", baseRequest.ContentType);
            if (baseRequest.Parameter != null)
            {
                //添加请求参数
                request.AddParameter("param", JsonConvert.SerializeObject(baseRequest.Parameter), ParameterType.RequestBody);
            }
            //获取请求返回值
            var response = await _client.ExecuteAsync(request);
            if (response.StatusCode == System.Net.HttpStatusCode.OK)
            {
                var res = JsonConvert.DeserializeObject<ApiResponse<T>>(response.Content);
                return res;
            }
            else
            {
                return new ApiResponse<T>()
                {
                    IsSuccess = false,
                    Message = response.ErrorMessage
                };
            }
        }
    }
}
```

这里的构造函数使用到了_apiUrl，需要在app.xaml.cs中进行注入

```C#
using System.Configuration;
using System.Data;
using System.Windows;
using System.Windows.Controls;
using DryIoc;
using MyTodo.Service;
using MyTodo.ViewModels;
using MyTodo.Views;
using Prism.DryIoc;
using Prism.Ioc;
using RestSharp;

namespace MyTodo
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : PrismApplication
    {
        protected override void RegisterTypes(IContainerRegistry containerRegistry)
        {
            //注册主页的导航页面(导航页面不依赖服务,所以不需要直接操作容器实例)
            containerRegistry.RegisterForNavigation<IndexView,IndexViewModel>();
            containerRegistry.RegisterForNavigation<MemoView, MemoViewModel>();
            containerRegistry.RegisterForNavigation<SettingsView, SettingsViewModel>();
            containerRegistry.RegisterForNavigation<TodoView, TodoViewModel>();
            //注册设置页的导航页面
            containerRegistry.RegisterForNavigation<SkinView, SkinViewModel>();
            containerRegistry.RegisterForNavigation<AboutView, AboutViewModel>();

            //https://localhost:7147/swagger/index.html
            //获取容器注册器实例
            var container = containerRegistry.GetContainer();
            //注册"webUrl"这个服务标识对应的实例
            container.RegisterInstance(@"https://localhost:7147/", serviceKey: "webUrl");
            //然后注册依赖这个实例的HttpRestClient服务
            container.Register<HttpRestClient>(made: Parameters.Of.Type<string>(serviceKey: "webUrl"));
        }

        protected override Window CreateShell()
        {
            return Container.Resolve<MainView>();
        }
    }
}

```

需要注意的是注入的时候不能像导航页面一样直接注入，要先获取到容器实例`container`，再将`ip:port`部分标记为serviceKey="webUrl"的值，最后注册依赖webUrl实例的HttpRestClient服务。

> 服务标识(Service Key)是一个很重要的概念,它在.NET Core依赖注入容器中的作用如下:
>
> - 服务标识是唯一识别一个注册服务的字符串。
> - 当向容器注册服务时,我们需要指定一个标识。例如上面代码注册"webUrl"字符串实例就是指定了"webUrl"作为标识。
> - 其他服务如果需要使用这个服务,就需要通过相同的标识来解决依赖。
> - 举个简单的例子,如果我们有一个UserService依赖一个数据库服务,在注册时可能是:
>
> ```C#
> services.AddTransient<UserService>();
> services.AddScoped<IDatabase, SqlDatabase>("database");
> ```
>
> 这里IDatabase实现指定了"database"作为标识。
>
> UserService在构造函数中注入时就可以写为:
>
> ```c#
> public UserService(IDatabase database) 
> ```
>
> 而容器会自动用"database"标识找到对应的SqlDatabase来满足依赖。
>
> 所以从技术角度来说,服务标识就相当于一个唯一名称,它使得依赖关系在代码和配置文件中实现了松耦合。

### 3）构造通用BaseService执行泛型方法

IBaseService接口就对应了webapi中各个方法

```C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MyTodo.Shared;
using MyTodo.Shared.Collections;
using MyTodo.Shared.Parameters;

namespace MyTodo.Service
{
    /// <summary>
    /// 约束TEntity必须是引用类型(class)
    /// </summary>
    /// <typeparam name="TEntity"></typeparam>
    public interface IBaseService<TEntity> where TEntity : class
    {
        Task<ApiResponse<TEntity>> AddAsync(TEntity entity);
        Task<ApiResponse<TEntity>> UpdateAsync(TEntity entity);
        Task<ApiResponse> DeleteAsync(int id);
        Task<ApiResponse<TEntity>> GetFirstOrDefaultAsync(int id);
        Task<ApiResponse<PagedList<TEntity>>> GetAllAsync(QueryParameter parameter);

    }
}
```

首先new一个类BaseRequest作为请求方法的参数类

```C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using RestSharp;

namespace MyTodo.Service
{
    public class BaseRequest
    {
        public Method Method { get; set; }
        public string Route { get; set; }
        public string ContentType { get; set; } = "application/json";
        public object? Parameter { get; set; }
    }
}
```

BaseService实现IBaseService

```C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection.Metadata;
using System.Text;
using System.Threading.Tasks;
using MyTodo.Shared;
using MyTodo.Shared.Collections;
using RestSharp;
using QueryParameter = MyTodo.Shared.Parameters.QueryParameter;

namespace MyTodo.Service
{
    public  class BaseService<TEntity> : IBaseService<TEntity> where TEntity : class
    {
        private readonly HttpRestClient _client;
        private readonly string _serviceName;
        public BaseService(HttpRestClient client, string serviceName)
        {
            _client = client;
            this._serviceName = serviceName;
        }

        public async Task<ApiResponse<TEntity>> AddAsync(TEntity entity)
        {
            BaseRequest request = new BaseRequest();
            request.Method = RestSharp.Method.Post;
            request.Route = $"api/{_serviceName}/Add";
            request.Parameter = entity;
            return await _client.ExecuteAsync<TEntity>(request); 
        }

        public async Task<ApiResponse<TEntity>> UpdateAsync(TEntity entity)
        {
            BaseRequest request = new BaseRequest();
            request.Method = RestSharp.Method.Post;
            request.Route = $"api/{_serviceName}/Update";
            request.Parameter = entity;
            return await _client.ExecuteAsync<TEntity>(request);
        }

        public async Task<ApiResponse> DeleteAsync(int id)
        {
            BaseRequest request = new BaseRequest();
            request.Method = RestSharp.Method.Delete;
            request.Route = $"api/{_serviceName}/Delete?id={id}";
            return await _client.ExecuteAsync(request);
        }

        public async Task<ApiResponse<TEntity>> GetFirstOrDefaultAsync(int id)
        {
            BaseRequest request = new BaseRequest();
            request.Method = RestSharp.Method.Get;
            request.Route = $"api/{_serviceName}/Get?id={id}";
            return await _client.ExecuteAsync<TEntity>(request);
        }

        public async Task<ApiResponse<PagedList<TEntity>>> GetAllAsync(QueryParameter parameter)
        {
            BaseRequest request = new BaseRequest();
            request.Method = RestSharp.Method.Get;
            request.Route = $"api/{_serviceName}/GetAll?pageIndex={parameter.PageIndex}&pageSize={parameter.PageSize}&search={parameter.Search}";
            //request.Method = RestSharp.Method.Post;
            //request.Route = $"api/{_serviceName}/GetAll";
            //request.Parameter = parameter;
            return await _client.ExecuteAsync<PagedList<TEntity>>(request);
        }
    }
}
```

### 4）TodoService

ITodoService接口继承IBaseService

```C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MyTodo.Common.Models;
using MyTodo.Shared;
using MyTodo.Shared.Collections;
using MyTodo.Shared.Parameters;

namespace MyTodo.Service
{
    public interface ITodoService : IBaseService<TodoDto>
    {
     
    }
}
```

`TodoService`继承`BaseService<TodoDto>`，由于BaseService的构造函数中需要传入serviceName`  public BaseService(HttpRestClient client, string serviceName)`作为请求url的部分，这里就可以直接写成"Todo"

```C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MyTodo.Common.Models;
using MyTodo.Shared;
using MyTodo.Shared.Collections;
using MyTodo.Shared.Parameters;

namespace MyTodo.Service
{
    public class TodoService : BaseService<TodoDto>, ITodoService
    {
        public TodoService(HttpRestClient client) : base(client, "Todo")
        {

        }
    } 
}
```

同时在app.xaml.cs中添加ITodoService与TodoService的注入

```C#
using System.Configuration;
using System.Data;
using System.Windows;
using System.Windows.Controls;
using DryIoc;
using MyTodo.Service;
using MyTodo.ViewModels;
using MyTodo.Views;
using Prism.DryIoc;
using Prism.Ioc;
using RestSharp;

namespace MyTodo
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : PrismApplication
    {
        protected override void RegisterTypes(IContainerRegistry containerRegistry)
        {
            //注册主页的导航页面(导航页面不依赖服务,所以不需要直接操作容器实例)
            containerRegistry.RegisterForNavigation<IndexView,IndexViewModel>();
            containerRegistry.RegisterForNavigation<MemoView, MemoViewModel>();
            containerRegistry.RegisterForNavigation<SettingsView, SettingsViewModel>();
            containerRegistry.RegisterForNavigation<TodoView, TodoViewModel>();
            //注册设置页的导航页面
            containerRegistry.RegisterForNavigation<SkinView, SkinViewModel>();
            containerRegistry.RegisterForNavigation<AboutView, AboutViewModel>();

            //https://localhost:7147/swagger/index.html
            //获取容器注册器实例
            var container = containerRegistry.GetContainer();
            //注册"webUrl"这个服务标识对应的实例
            container.RegisterInstance(@"https://localhost:7147/", serviceKey: "webUrl");
            //然后注册依赖这个实例的HttpRestClient服务
            container.Register<HttpRestClient>(made: Parameters.Of.Type<string>(serviceKey: "webUrl"));
            //添加服务的注入
            containerRegistry.Register<ITodoService, TodoService>();

        }

        protected override Window CreateShell()
        {
            return Container.Resolve<MainView>();
        }
    }
}

```

### 5）修改TodoViewModel的初始化数据方法

```C#
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MyTodo.Common.Models;
using MyTodo.Service;
using MyTodo.Shared.Parameters;
using Prism.Commands;
using Prism.Mvvm;

namespace MyTodo.ViewModels
{
    public class TodoViewModel : BindableBase
    {
        private readonly ITodoService _todoService;
        /// <summary>
        /// 按钮绑定的添加待办命令
        /// </summary>
        public DelegateCommand TodoAddCommand { get; set; }
        public TodoViewModel(ITodoService todoService)
        {
            _todoService = todoService;
            TodoList = new ObservableCollection<TodoDto>();
            InitialTodoList();
            TodoAddCommand = new DelegateCommand(AddTodoAction);
        }
        private ObservableCollection<TodoDto> todoList;

        public ObservableCollection<TodoDto> TodoList
        {
            get { return todoList; }
            set { todoList = value; RaisePropertyChanged(); }
        }
        private bool isRightDrawerOpen;
        /// <summary>
        /// 右侧抽屉是否展开
        /// </summary>
        public bool IsRightDrawerOpen
        {
            get { return isRightDrawerOpen; }
            //set { isRightDrawerOpen = value; RaisePropertyChanged(); }
            set { SetProperty(ref isRightDrawerOpen, value); }
        }

        private async void InitialTodoList()
        {
            var res = await _todoService.GetAllAsync(new QueryParameter()
            {
                PageSize = 100,PageIndex = 0
            });
            if (res.IsSuccess)
            {
                TodoList.Clear();
                foreach (var item in res.Result.Items)
                {
                    TodoList.Add(item);
                }
            }
            //for (int i = 0; i < 20; i++)
            //{
            //    var todo = new TodoDto()
            //    {
            //        Id = i,
            //        CreateTime = DateTime.Now,
            //        Content = "测试数据",
            //        Title = "标题" + i,
            //        Status = 1,
            //        UpdateTime = DateTime.Now
            //    };
            //    todoList.Add(todo);
            //}
        }
        //TodoAddCommand命令执行的方法
        private void AddTodoAction()
        {
            IsRightDrawerOpen = true;
        }
    }
}
```

### 6）配置启动项与效果

![image-20240609231609400](../TyporaImgs/image-20240609231609400.png)

启动后先用api测试请求url是否正确

```text
https://localhost:7147/api/Todo/GetAll?PageIndex=0&PageSize=100
```

在wpf中打开待办页可以看到之前在数据库中添加的数据

![image-20240609231721971](../TyporaImgs/image-20240609231721971.png)

## 2、MemoService

### 1）修改MemoViewModel、IndexViewModel初始化数据

IMemoService

```C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MyTodo.Common.Models;
using MyTodo.Shared.Dtos;

namespace MyTodo.Service
{
    public interface IMemoService :  IBaseService<MemoDto>
    {
    }
}
```

MemoService

```C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MyTodo.Common.Models;
using MyTodo.Shared;
using MyTodo.Shared.Collections;
using MyTodo.Shared.Dtos;
using MyTodo.Shared.Parameters;

namespace MyTodo.Service
{
    public class MemoService : BaseService<MemoDto>, IMemoService
    {
        public MemoService(HttpRestClient client) : base(client, "Memo")
        { 

        }
    }
}
```

在MemoViewModel中修改`InitialMeomoList`方法，改为从数据库提取数据

```C#
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MyTodo.Common.Models;
using MyTodo.Service;
using MyTodo.Shared.Dtos;
using MyTodo.Shared.Parameters;
using Prism.Commands;
using Prism.Mvvm;

namespace MyTodo.ViewModels
{
    public class MemoViewModel :BindableBase
    {
        public IMemoService _memoService { get; set; }
        public MemoViewModel(IMemoService memoService, ObservableCollection<MemoDto> memoList)
        {
            _memoService = memoService;
            this.memoList = memoList;
            //初始化数据
            MemoList = new ObservableCollection<MemoDto>();
            InitialMeomoList();
            //命令属性绑定方法
            MemoAddCommand = new DelegateCommand(AddMemoAction);
        }
        //数据属性 列表
        private ObservableCollection<MemoDto> memoList;

		public ObservableCollection<MemoDto> MemoList
        {
			get { return memoList; }
			set { memoList = value; RaisePropertyChanged();}
		}
        //数据属性 右侧的弹窗是否打开
        private bool isRightDrawerOpen;

        public bool IsRightDrawerOpen
        {
            get { return isRightDrawerOpen; }
            set { isRightDrawerOpen = value; RaisePropertyChanged();}
        }
        //命令属性 新增备忘命令
        public DelegateCommand MemoAddCommand { get; set; }

        private void AddMemoAction()
        {
            IsRightDrawerOpen = true;
        }
        private async void InitialMeomoList()
        {
            var res = await _memoService.GetAllAsync(new QueryParameter()
            {
                PageSize = 100,
                PageIndex = 0
            });
            if (res.IsSuccess)
            {
                MemoList.Clear();
                foreach (var item in res.Result.Items)
                {
                    MemoList.Add(item);
                }
            }
            //for (int i = 0; i < 20; i++)
            //{
            //    var mome = new MemoDto()
            //    {
            //        Id = i,
            //        CreateTime = DateTime.Now,
            //        Content = "测试数据",
            //        Title = "标题" + i,
            //        Status = 1,
            //        UpdateTime = DateTime.Now
            //    };
            //    MemoList.Add(mome);
            //}
        }
    }
}
```

在IndexViewModel中修改`InitialTestData`方法，改为从数据库提取数据

```C#
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MyTodo.Common.Models;
using MyTodo.Service;
using MyTodo.Shared.Dtos;
using MyTodo.Shared.Parameters;
using Prism.Mvvm;

namespace MyTodo.ViewModels
{
    public class IndexViewModel : BindableBase
    {
        private readonly IMemoService _memoService;
        private readonly ITodoService _todoService;
        public IndexViewModel(IMemoService memoService, ITodoService todoService)
        {
            _memoService = memoService;
            _todoService = todoService;
            TaskBars = new ObservableCollection<TaskBar>();
            InitialTaskBars();
            InitialTestData();
        }
        private ObservableCollection<TaskBar> taskBars;

        public ObservableCollection<TaskBar> TaskBars
        {
            get { return taskBars; }
            set { taskBars = value; RaisePropertyChanged(); }
        }

        void InitialTaskBars()
        {
            TaskBars.Add(new TaskBar() { Icon = "ClockFast", Title = "汇总", Content = "9", Color = "#FF0CA0FF", Target = "" });
            TaskBars.Add(new TaskBar() { Icon = "ClockCheckOutline", Title = "已完成", Content = "9", Color = "#FF1ECA3A", Target = "" });
            TaskBars.Add(new TaskBar() { Icon = "ChartLineVariant", Title = "完成比例", Content = "100%", Color = "#FF02C6DC", Target = "" });
            TaskBars.Add(new TaskBar() { Icon = "PlaylistStar", Title = "备忘录", Content = "19", Color = "#FFFFA000", Target = "" });
        }

        private ObservableCollection<TodoDto> todoList;

        public ObservableCollection<TodoDto> TodoList
        {
            get { return todoList; }
            set
            {
                todoList = value;
                RaisePropertyChanged();
            }
        }

        private ObservableCollection<MemoDto> memoList;

        public ObservableCollection<MemoDto> MemoList
        {
            get { return memoList; }
            set
            {
                memoList = value;
                RaisePropertyChanged();
            }
        }
        private async void InitialTestData()
        {
            TodoList = new ObservableCollection<TodoDto>();
            MemoList = new ObservableCollection<MemoDto>();
            var param = new QueryParameter()
            {
                PageSize = 100,
                PageIndex = 0
            };
            var memoRes = await _memoService.GetAllAsync(param);
            if (memoRes.IsSuccess)
            {
                MemoList.Clear();
                foreach (var item in memoRes.Result.Items)
                {
                    MemoList.Add(item);
                }
            }
            var todoRes = await _todoService.GetAllAsync(param);
            if (memoRes.IsSuccess)
            {
                TodoList.Clear();
                foreach (var item in todoRes.Result.Items)
                {
                    TodoList.Add(item);
                }
            }
            //for (int i = 0; i < 10; i++)
            //{
            //    var todo = new TodoDto()
            //    {
            //        Id = i,
            //        Content = "正在处理中",
            //        Title = "待办"+i,
            //        Status = 1,
            //    };
            //    var memo = new MemoDto()
            //    {
            //        Id = i,
            //        Content = "我的密码",
            //        Title = "待办" + i,
            //        Status = 1,
            //    };
            //    todoList.Add(todo);
            //    MemoList.Add(memo);
            //}
        } 
    }
}
```

在app.xaml.cs文件中添加IMemoService与MemoService的服务注入

```C#
containerRegistry.Register<IMemoService, MemoService>();
```

### 2）

## 3、Loading的加载动画

Loading的原理是通过MainView订阅参数为UpdateModel（属性IsOpen）的委托，进入TodoView时，其构造方法中发布类型UpdateModel的事件，当消息监听到事件后委托中`MainDialogHost.DialogContent = new LoadingView()`显示Loading页面，当数据加载完成则再次触发事件，关闭Loading页面。

其中UpdateModel为消息类型，UpdateLoadingEvent为订阅的事件

```C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Prism.Events;

namespace MyTodo.Common.Events
{
    public class UpdateModel
    {
        public bool IsOpen { get; set; }

        public UpdateModel(bool isOpen)
        {
            IsOpen = isOpen;
        }

        public UpdateModel()
        {
        }
    }
    /// <summary>
    /// 被订阅的事件(消息类型:UpdateModel)需要继承PubSubEvent类
    /// </summary>
    public class UpdateLoadingEvent : PubSubEvent<UpdateModel>
    {
    }
}
```

MainView.cs中订阅事件

```C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using MyTodo.Extensions;
using Prism.Events;

namespace MyTodo.Views
{
    /// <summary>
    /// MainView.xaml 的交互逻辑
    /// </summary>
    public partial class MainView : Window
    {
        public MainView(IEventAggregator aggregator)
        {
            InitializeComponent();
            //订阅参数为UpdateModel的委托，当消息发布后委托执行如下方法：
            aggregator.Register(arg =>
            {
                MainDialogHost.IsOpen = arg.IsOpen;
                if (MainDialogHost.IsOpen)
                {
                    //如果主页面打开，则显示LoadingView
                    MainDialogHost.DialogContent = new LoadingView();
                }
            });
            //最小化、最大化、关闭触发事件
			...
            //鼠标长摁实现拖动
            ...
            //鼠标双击顶部的bar实现放大缩小的切换
           ...
            //鼠标点击切换左侧抽屉导航时，关闭抽屉
          ...
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {

        }
    }
}

```

其中的`aggregator.Register`是针对`IEventAggregator`类型的拓展方法：

```C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using ImTools;
using MyTodo.Common.Events;
using Prism.Events;

namespace MyTodo.Extensions
{
    /// <summary>
    /// IEventAggregator 类型实例的拓展方法
    /// </summary>
    public static class DialogExtension
    {
        /// <summary>
        /// 发布消息为类型UpdateModel的事件
        /// </summary>
        /// <param name="aggregator"></param>
        /// <param name="model">被发布的消息</param>
        public static void UpdateLoading(this IEventAggregator aggregator, UpdateModel model)
        {
            aggregator.GetEvent<UpdateLoadingEvent>().Publish(model);
        }
        /// <summary>
        /// 订阅参数为UpdateModel的委托action，委托指向要执行的事件
        /// </summary>
        /// <param name="aggregator"></param>
        /// <param name="action">被订阅的事件</param>
        public static void Register(this IEventAggregator aggregator, Action<UpdateModel> action)
        {
            aggregator.GetEvent<UpdateLoadingEvent>().Subscribe(action);
        }
    }
}

```

触发事件后显示的页面`LoadingView`如下：

```xml
<UserControl x:Class="MyTodo.Views.LoadingView" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:local="clr-namespace:MyTodo.Views" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             d:DesignHeight="450" d:DesignWidth="800"
             mc:Ignorable="d">
    <Grid>
        <StackPanel Width="100">
            <ProgressBar Width="40" Height="40"
                         Margin="20" IsIndeterminate="True"
                         Style="{StaticResource MaterialDesignCircularProgressBar}" />
        </StackPanel>
    </Grid>
</UserControl>

```

`TodoViewModel`中发起事件，这里需要引入`NavigationViewModel`类继承`BindableBase`（因为TodoViewModel原继承自BindableBase），实现`INavigationAware`（处理路由导航的生命周期事件，当`MainView`导航到`TodoView`时调用`OnNavigatedTo()`方法）

```C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MyTodo.Common.Events;
using MyTodo.Extensions;
using Prism.Events;
using Prism.Ioc;
using Prism.Mvvm;
using Prism.Regions;

namespace MyTodo.ViewModels
{
    public class NavigationViewModel :BindableBase, INavigationAware
    {
        //dryIoc中的容器
        private readonly IContainerProvider _containerProvider;
        public readonly IEventAggregator _aggregator;
        public NavigationViewModel(IContainerProvider containerProvider)
        {
            _containerProvider = containerProvider;
            _aggregator = containerProvider.Resolve<IEventAggregator>();
        }

        /// <summary>
        /// 导航到该组件时调用
        /// </summary>
        /// <param name="navigationContext"></param>
        public virtual void OnNavigatedTo(NavigationContext navigationContext)
        {

        }
        /// <summary>
        /// 导航离开该组件时调用
        /// </summary>
        /// <param name="navigationContext"></param>
        /// <returns></returns>
        public virtual bool IsNavigationTarget(NavigationContext navigationContext)
        {
            return true;
        }
        /// <summary>
        /// 当组件即将被导航到时调用
        /// </summary>
        /// <param name="navigationContext"></param>
        public virtual void OnNavigatedFrom(NavigationContext navigationContext)
        {

        }
		//发布消息为类型UpdateModel的事件(给子类调用)
        public void UpdateLoading(bool IsOpen)
        {
            _aggregator.UpdateLoading(new UpdateModel(IsOpen));
        }
    }
}

```

`TodoViewModel`继承`NavigationViewModel`，使用`UpdateLoading(true); `发起事件，最终被MainView监听到后执行对应的方法。

```C#
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MyTodo.Common.Models;
using MyTodo.Service;
using MyTodo.Shared.Dtos;
using MyTodo.Shared.Parameters;
using Prism.Commands;
using Prism.Events;
using Prism.Ioc;
using Prism.Mvvm;
using Prism.Regions;

namespace MyTodo.ViewModels
{
    public class TodoViewModel : NavigationViewModel
    {
        private readonly ITodoService _todoService;
        //dryIoc中的容器
        private readonly IContainerProvider _containerProvider;

        /// <summary>
        /// 按钮绑定的添加待办命令
        /// </summary>
        public DelegateCommand TodoAddCommand { get; set; }
        public TodoViewModel(ITodoService todoService,IContainerProvider containerProvider) : base(containerProvider)
        {
            _containerProvider = containerProvider;
            _todoService = todoService;
            TodoList = new ObservableCollection<TodoDto>();
            //InitialTodoList();
            TodoAddCommand = new DelegateCommand(AddTodoAction);
        }

       ...
        /// <summary>
        /// 获取数据
        /// </summary>
        private async void InitialTodoList()
        {
           //发布消息为类型UpdateModel的事件
            UpdateLoading(true); //加载开始
            var res = await _todoService.GetAllAsync(new QueryParameter()
            {
                PageSize = 100,PageIndex = 0
            });
            if (res.IsSuccess)
            {
                TodoList.Clear();
                //TodoList = new ObservableCollection<TodoDto>();
                foreach (var item in res.Result.Items)
                {
                    TodoList.Add(item);
                }
            }
            UpdateLoading(false); //加载结束
        }
        /// <summary>
        /// 导航到当前组件时执行初始化数据的方法
        /// </summary>
        public override void OnNavigatedTo(NavigationContext navigationContext)
        {
            base.OnNavigatedTo(navigationContext);
            InitialTodoList();
        }

        //TodoAddCommand命令执行的方法
        ...
    }
}
```

效果：

![](../TyporaImgs/LoadingAnimation.gif)
