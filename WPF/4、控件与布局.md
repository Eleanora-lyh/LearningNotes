## 1、控件

WPF把那些能够展示数据、响应用户操作的UI元素称为控件(Control)。控件所展示的数据，我们称之为控件的“数据内容”;控件在响应用户的操作后会执行自己的一些方法或以事件(Event)的形式通知应用程序(程序员可以决定如何处理这些事件)，我们称之为控件的“行为”或“算法内容”。可见，WPF中的控件扮演着双重角色——Control是数据和行为的载体。

常用控件有6类：

1. 布局控件：可以容纳多个控件或嵌套其他布局控件，用于在 UI上组织和排列控件。Grid、StackPanel、DockPanel 等控件都属此类，它们拥有共同的父类Panel。
2. 内容控件：只能容纳一个其他控件或布局控件作为它的内容。Window、Button等控件属于此类，因为只能容纳一个控件作为其内容，所以经常需要借助布局控件来规划其内容。它们的共同父类是 ContentControl。
3. 带标题内容控件：相当于一个内容控件，但可以加一个标题(Header)，标题部分亦可容纳一个控件或布局。GroupBox、Tabltem等是这类控件的典型代表。它们的共同父类是 HeaderedContentControl
4. 条目控件：可以显示一列数据，一般情况下这列数据的类型相同。此类控件包括 ListBoxComboBox等。它们的共同基类是 ItemsControl。此类控件在显示集合类型数据方面功能非常强大。
5. 带标题条目控件：相当于一个条目控件加上一个标题显示区。TreeViewItem、Menultem 都属于此类控件。这类控件往往用于显示层级关系数据，结点显示在其Header 区域，子级结点则显示在其条目控件区域。此类控件的共同基类是HeaderedItemsControl。
6. 特殊内容控件：比如 TextBox容纳的是字符串、TextBlock 可以容纳可自由控制格式的文本、Image 容纳图片类型数据，这类控件相对比较独立。

## 2、WPF内容模型

WPF的UI会形成一个树形结构，如果不考虑控件内部的组成结构，只观察由**控件组成的“树”，那么这棵树称为逻辑树(LogicalTree)**；WPF控件往往是由更基本的控件构成的，即控件本身就是一棵树，如果**连控件本身的树也考虑在内**，则这棵比逻辑树更“繁茂”的树称为**可视元素树(VisualTree)**

控件是内存中的对象，控件的内容也是内存中的对象。控件通过自己的某个属性引用着作为其内容的对象，这个属性称为**内容属性(ContentProperty)**。“内容属性”是个统称，具体到每种控件上，内容属性都有自己确切的名字--有的直接就叫Content，有的叫Child；有些控件的内容可以是集合，其内容属性有叫Items或Children的。
控件的内容属性与XAML标签的内容存在一定的对应关系，下面稍做解释。

## 3、各类内容模型详解

### 3.1、ContentControl族

单一内容控件，本族元素的特点如下:

- 均派生自ContentControl类
- 它们都是控件(Control)。
- 内容属性的名称为 Content。
- 只能由单一元素充当其内容。

```xmal
<Window x:Class="HelloWPF2.ContentControl"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:HelloWPF2"
        mc:Ignorable="d"
        Title="ContentControl" Height="450" Width="800">
    <StackPanel>
        <Button Margin="5">
            <TextBlock Text="Hello"/>
        </Button>
        <Button Margin="5">
            <Image Source=".\imgs\green.jpg" Width="30" Height="30"/>
        </Button>
        <GroupBox Margin="10" BorderBrush="Gray">
            <GroupBox.Header>
                <Image Source=".\imgs\yellowcar.jpg" Width="30" Height="30"/>
            </GroupBox.Header>
            <TextBlock TextWrapping="WrapWithOverflow" Margin="10" Text="一棵树、一匹马、一头大象和一只鸡打在一起，打一种日常品"/>
        </GroupBox>
    </StackPanel>
</Window>

```



### 3.2、HeaderdContentControl族

带标题的单一内容控件

```xmal
<Window x:Class="HelloWPF2.ContentControl"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:HelloWPF2"
        mc:Ignorable="d"
        Title="ContentControl" Height="450" Width="800">
    <StackPanel>
        <GroupBox Margin="10" BorderBrush="Gray">
            <GroupBox.Header>
                <Image Source=".\imgs\yellowcar.jpg" Width="30" Height="30"/>
            </GroupBox.Header>
            <TextBlock TextWrapping="WrapWithOverflow" Margin="10" Text="一棵树、一匹马、一头大象和一只鸡打在一起，打一种日常品"/>
        </GroupBox>
    </StackPanel>
</Window>

```

![image-20240411214107578](../TyporaImgs/image-20240411214107578.png)

### 3.3、ItemsControl族

以条目集合为内容的控件，本族元素的特点如下:

- 均派生自 ItemsControl类。
- 它们都是控件，用于显示列表化的数据。
- 内容属性为Items或ItemsSource
- 每种 ItemsControl都对应有自己的条目容器(Item Container)。

WPF的U是树形结构，```VisualTreeHelper``` 类就是帮助我们在这棵由可视化元素构成的树上进行导航的辅助类。我们沿着被单击的 Button 一层一层向上找，找到第三层发现它是一个 ListBoxltem。ListBoxltem 就是ListBox对应的 Item Container，也就是说，无论你把什么样的数据集合交给ListBox，它都会以这种方式进行自动包装。

```xmal
<Window x:Class="HelloWPF2.ItemControl"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:HelloWPF2"
        mc:Ignorable="d"
        Title="ItemControl" Height="450" Width="800">
    <Grid>
        <ListBox Margin="5">
            <CheckBox x:Name="checkBoxTim" Content="Tim"/>
            <CheckBox x:Name="checkBoxTom" Content="Tom"/>
            <CheckBox x:Name="checkBoxBruce" Content="Bruce"/>
            <Button x:Name="buttonMess" Content="Mess"/>
            <Button x:Name="buttonOwen" Content="Owen"/>
            <Button x:Name="buttonVictor" Content="Victor" Click="buttonVictor_Click"/>
        </ListBox>
    </Grid>
</Window>

```

.cs文件

```C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace HelloWPF2
{
    /// <summary>
    /// ItemControl.xaml 的交互逻辑
    /// </summary>
    public partial class ItemControl : Window
    {
        public ItemControl()
        {
            InitializeComponent();
        }

        private void buttonVictor_Click(object sender, RoutedEventArgs e)
        {
            Button vic = sender as Button; //VisualTreeHelper可视化元素构成的树上进行导航
            DependencyObject l1 = VisualTreeHelper.GetParent(vic);
            DependencyObject l2 = VisualTreeHelper.GetParent(l1);
            DependencyObject l3 = VisualTreeHelper.GetParent(l2);
            MessageBox.Show(l3.GetType().ToString());
        }
    }
}

```



<img src="../TyporaImgs/image-20240411220132383.png" alt="image-20240411220132383" style="zoom:50%;" />

上面这个例子是单纯地为了说明ItemsControl能够使用对应的Item Container 自动包装数据。

实际工作中，除非列表里的元素自始至终都是固定的我们才使用这种直接把U元素作为ItemsControl 内容的方法，比如一年有十二个月、一周有七天等。大多数情况下，UI上的列表会用于显示动态的后台数据，这时候我们交给ItemsControl的就是程序逻辑中的数据而非控件了。

定义列表中的显示的对象类Employee

```C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace HelloWPF2.Entities
{
    public class Employee
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public int Age { get; set; }

        public Employee(int id, string name, int age)
        {
            Id = id;
            Name = name;
            Age = age;
        }
    }
}
```

xmal设计：

```xmal
<ListBox Margin="0,5,10,5" Grid.Column="1" x:Name="EmployeeListBox"/>
```

.cs文件 中绑定xmal中的ListBox，设置其数据源

```C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using HelloWPF2.Entities;

namespace HelloWPF2
{
    /// <summary>
    /// ItemControl.xaml 的交互逻辑
    /// </summary>
    public partial class ItemControl : Window
    {
        List<Employee> employees = new List<Employee>()
        {
            new Employee(1,"Tim",22) , new Employee(2,"Tom",22) , 
            new Employee(3,"Owen",22) ,new Employee(4,"Victor",22) ,
            new Employee(5,"Liu",22) ,new Employee(6,"Hu",22) 
        };
        public ItemControl()
        {
            InitializeComponent();
            //DisplayMemberPath告诉ListBox显示每条数据的哪个属性
            //调用这个属性值的 ToString()方法，把得到的字符串放入一个TextBlock(最简单的文本控件)，然后再把TextBlock包装进一个ListBoxltem里
            this.EmployeeListBox.DisplayMemberPath = "Name";
            this.EmployeeListBox.SelectedValuePath = "Id";
            this.EmployeeListBox.ItemsSource = employees;
        }
    }
}

```

效果：

![image-20240411221932184](../TyporaImgs/image-20240411221932184.png)

```DisplayMemberPath```告诉ListBox显示每条数据的哪个属性，调用这个属性值的 ToString()方法，把得到的字符串放入一个TextBlock(最简单的文本控件)，然后再把TextBlock包装进一个ListBoxltem里

```SelectedValuePath```与```SelectedValue```配合使用：当调用SelectedValue属性时，ListBox先找到选中的Item所对应的数据对象，然后把SelectedValuePath的值当作数据对象的属性名称并把这个属性的值取出来。

DisplayMemberPath 和 SelectedValuePath 是两个相当简化的属性。**DisplayMemberPath 只能显示简单的字符串，想用更加复杂的形式显示数据需要使用 DataTemplate**，我们在后面的章节详细讨论：**SelectedValuePath 也只能返回单一的值**，如果想进行一些复杂的操作，不妨直接使用ListBox的Selectedltem 和 Selectedltems属性，这两个属性返回的就是数据集合中的对象，得到原始的数据对象后就任由程序员操作了。

### 3.4、HeaderItemControl族

带标题的以条目集合为内容的控件，顾名思义，本族控件除了具有ItemsControl的特性外，还具显示标题的能力。本族元素的特点如下:

- 均派生自 HeaderedItemsControl 类。

- 它们都是控件，用于显示列表化的数据，同时可以显示一个标题
- 内容属性为Items、ItemsSource 和 Header

本族控件只有3个:Menultem、TreeViewltem、ToolBar.

### 3.5、Decorator族

控件装饰元素，本族中的元素是在 UI上起装饰效果的。如可以使用 Border 元素为一些组织在一起的内容加个边框。如果需要组织在一起的内容能够自由缩放，则可使用 ViewBox元素。本族元素的特点如下:

- 均派生自 Decorator 类。
- 起 UI 装饰作用。
- 内容属性为Child。
- 只能由单一元素充当内容。



### 3.6、TextBlock和TextBox

文本输入框，静态文字 这两个控件最主要的功能是显示文本。

|          | TextBlock 静态文本                           | TextBox 文本输入框 |
| -------- | -------------------------------------------- | ------------------ |
| 能否编辑 | 不能编辑                                     | 能编辑             |
| 排版     | 丰富的印刷级的格式控制标记显示专业的排版效果 | 简单的字符串       |
| 内容属性 | Inlines(印刷中的“行”) + Text                 | Text               |

### 3.7、Shape族元素

图形元素

友好的用户界面离不开各种图形的搭配，Shape族元素(它们只是简单的视觉元素，不是控件)就是专门用来在 UI 上绘制图形的一类元素。这类元素没有自己的内容，我们可以使用 Fill 属性为它们设置填充效果，还可以使用Stroke属性为它们设置边线的效果。本族元素的特点如下:

- 均派生自 Shape 类
- 用于 2D 图形绘制。
- 无内容属性。
- 使用Fill 属性设置填充，使用Stroke属性设置边线。

### 3.8、Panel族元素

所有用于U布局的元素都属于这一族，本族元素的特点如下:

- 均派生自 Panel 抽象类。
- 主要功能是控制 U布局。
- 内容属性为Children。内容可以是多个元素，Panel元素将控制它们的布局。

对比 ItemsControl和 Panel 元素，虽然内容都可以是多个元素，但ItemsControl 强调以列表的形式来展现数据而Panel则强调对包含的元素进行布局,所以ItemsControl的内容属性是 Items和ItemsSource而Panel的内容属性名为Children。

Adorner 文字点缀元素

## 4、UI布局 Layout

### 4.1布局元素

### 4.2、Grid

### 4.3、StackPanel

面板类元素

### 4.4、Canvas

### 4.5、DockPanel

```bash
NuGet\Install-Package Prism.Wpf -Version 8.1.97
```

