## 0、控制反转 Inversion of Control（IOC）

IOC的实现方式：服务定位器ServiceLocator、依赖注入DependencyInjection；在.net 中控制反转的组件名为 DependencyInjection（包括ServiceLocator）

服务（对象），注册服务，服务容器、对象生命周期（Transient瞬态、Scoped范围、Singleton单例）

服务类型用接口，实现类型用接口的实现类

```shell
NuGet\Install-Package Microsoft.Extensions.DependencyInjection -Version 6.0.0
```

1、给类构造函数中打印，看看不同生命周期的对象创建使用serviceProvider.CreateScope()创建Scope。

2、如果一个类实现了IDisposable接口，则离开作用域之后容器会自动调用对象的Dispose方法。

3、不要在长生命周期的对象中引用比它短的生命周期的对象。在ASP.NET Core中，这样做默认会抛异常。

4、生命周期的选择:如果类无状态(没有成员变量和属性)，建议为Singleton;如果类有状态，且有Scope控制，建议为Scoped，因为通常这种Scope控制下的代码都是运行在同一个线程中的，没有并发修改的问题;在使用Transient的时候要谨慎。5、.NET注册服务的重载方法很多，看着文档琢磨吧

## 1、服务生命周期

### 1.1 Transient

每次通过 AddTransient 注册的服务 新增的类对象都是不同的

```C#
ServiceCollection services = new ServiceCollection();
services.AddTransient<TestServiceImpl>(); //瞬态
using (ServiceProvider serviceProvider = services.BuildServiceProvider())
{
    TestServiceImpl t1 = serviceProvider.GetService<TestServiceImpl>();
    TestServiceImpl t2 = serviceProvider.GetService<TestServiceImpl>();
    Console.WriteLine(Object.ReferenceEquals(t1, t2)); //False
}
```

### 1.2、Scoped

每次通过 AddTransient 注册的服务 新增的类对象都是不同的

```C#
public void TestServiceProvider()
{
    ServiceCollection services = new ServiceCollection();
    services.AddScoped<TestServiceImpl>();
    using (ServiceProvider sp = services.BuildServiceProvider())
    {
        using(IServiceScope scope1 = sp.CreateScope())
        {
            //在scope中获取scope相关对象
            TestServiceImpl t3 = scope1.ServiceProvider.GetService<TestServiceImpl>();
            TestServiceImpl t4 = scope1.ServiceProvider.GetService<TestServiceImpl>();
            Console.WriteLine(Object.ReferenceEquals(t3, t4));//True

        }
    }
}
```

## 2、服务定位器

### 2.1、Demo

测试使用到的实体类

```C#
namespace ConsoleApp1.IOCDemo
{
    public class TestServiceImpl : ITestService
    {
        public string name { get; set; }
        public void sayHi()
        {
            Console.WriteLine("Hi " + this.name) ;
        }
    }
}
```

IOC服务注入类

```c#
using System;
using System.Collections.Generic;
using ConsoleApp1.IOCDemo;
using Microsoft.Extensions.DependencyInjection;

namespace ConsoleApp1
{
    public class IOC
    {

        public void TestServiceProvider()
        {
            //ServiceCollention 用来构造容器对象
            ServiceCollection services = new ServiceCollection();
            //将服务注册到ServiceCollention
            services.AddTransient<TestServiceImpl>();
            //获取ServiceCollention 中注册的对象
            using (ServiceProvider serviceProvider = services.BuildServiceProvider())
            {
                //服务定位器
                TestServiceImpl testServiceImpl = serviceProvider.GetService<TestServiceImpl>();
                testServiceImpl.name = "lyh";
                testServiceImpl.sayHi();
            }
        }
        //
    }
}
```

program.cs 调用IOC服务注入类

```C#
new IOC().TestServiceProvider();
```

### 2.2、服务类型和实现类型不一致的注册

服务类型和实现类型不一致的注册（最好将服务类型写成接口）注册的是接口实际注入的是实现类。

一般是框架注册对象，程序员直接获取接口类型的服务，就是注册好的实现类型。

如果是这种方式的注入，那么获取服务类型的时候只能通过 注册的接口类型获取注入的对象，否则会报空对象异常的

```C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using ConsoleApp1.IOCDemo;
using Microsoft.Extensions.DependencyInjection;

namespace ConsoleApp1
{
    public class IOC //用于学习IOC控制反转的实现方式
    {
        //测试注册的服务为接口
        public void TestServiceProvider2()
        {
            ServiceCollection services = new ServiceCollection(); //ServiceCollention创建容器对象
            services.AddScoped<ITestService,TestServiceImpl>();//将服务注册到容器中
            services.AddSingleton(typeof(ITestService),new TestServiceImpl2()); //支持在new实现类的时候添加参数
            using (ServiceProvider sp = services.BuildServiceProvider()) //获取ServiceCollention 中注册的服务
            {
                ITestService x = sp.GetService<ITestService>(); //只会获取到最后一个注册的

                TestServiceImpl x2 = sp.GetService<TestServiceImpl>(); // 找不到服务，返回null

                ITestService x3 = (ITestService)sp.GetService(typeof(ITestService)); // 需要添加强制转换，一般在写框架用到反射的时候会用到

                ITestService x4 = sp.GetRequiredService<ITestService>();//如果获取了没有注册的对象会直接抛异常而不是返回null，如x44
                //TestServiceImpl x44 = sp.GetRequiredService<TestServiceImpl>();

                //实现接口的有多个服务
                IEnumerable<ITestService> x5 = sp.GetServices<ITestService>();
                foreach(var t in x5)
                {
                    Console.WriteLine("for:"+t.GetType());
                    //for:ConsoleApp1.IOCDemo.TestServiceImpl
                    //for:ConsoleApp1.IOCDemo.TestServiceImpl2
                }
                
                x.name = "lyh";
                x.sayHi();
                Console.WriteLine("last:"+x.GetType()); //last:ConsoleApp1.IOCDemo.TestServiceImpl2
            }
        }
    }
}

```

program.cs 调用IOC服务注入类

```C#
new IOC().TestServiceProvider2();
```

## 3、依赖注入

1、依赖注入是有"传染性”的，如果一个类的对象是**通过DI创建的，那么这个类的构造函数中声明的所有服务类型的参数都会被DI赋值**;但是如果一个对象是程序员手动创建的，那么这个对象就和DI没有关系，它的构造函数中声明的服务类型参数就不会被自动赋值。

2、.NET默认是构造函数注入。

```C#
namespace ConsoleApp1
{
    public class DependencyInjectionTest
    {
        private readonly IStorage _storage;
        private readonly ILog _log;
        public DependencyInjectionTest(IStorage storage, ILog log)
        {
            _storage = storage;
            _log = log;
        }
        public void Run()
        {
            _log.Log("开始上传.....");
            _storage.Save("rwerwe dfsdfscs", "1.txt");
            _log.Log("开始结束");
        }
    }
    //日志
    public interface ILog
    {
        public void Log(string message);
    }
    public class LogImpl : ILog
    {
        public void Log(string message)
        {
            Console.WriteLine(message);
        }
    }
      //配置文件
    public interface IConfig
    {
        public string GetPathByName(string name); //从配置文件中读服务器地址
    }
    public class ConfigImpl : IConfig //配置文件接口，根据输入获取服务器地址
    {
        public string GetPathByName(string name)
        {
            return "http://lyh.com";
        }
    }
    //存储
    public interface IStorage
    {
        public void Save(string name, string content); //保存文件名为name，内容为content的文件
    }
    public class StorageImpl : IStorage
    {
        private readonly IConfig _config;

        public StorageImpl(IConfig config) //构造函数注入
        {
            _config = config;
        }

        public void Save(string name,string content)
        {
            var server = _config.GetPathByName("server"); //获取服务器地址
            Console.WriteLine($"已向{server}上传文件名为{name},内容为{content}的文件");
        }
    }
}
```

program.cs中

```C#
ServiceCollection services = new ServiceCollection();
services.AddScoped<DependencyInjectionTest>();
services.AddScoped<ILog,LogImpl>();
services.AddScoped<IConfig, ConfigImpl>();
services.AddScoped<IStorage, StorageImpl>();
using(var scope = services.BuildServiceProvider())
{
    //通过DI创建的，那么这个类的构造函数中声明的所有服务类型的参数都会被DI赋值
    var item = scope.GetRequiredService<DependencyInjectionTest>();
    item.Run();
}
```

输出：

```json
开始上传.....
已向http://lyh.com上传文件名为rwerwe dfsdfscs,内容为1.txt的文件
开始结束
```

当配置的实现类改变时，只需要新增一个配置的实现类，并在program中将配置的实现类进行注入，就可以直接变更，降低模块之间的耦合程度。

## 4、复杂依赖注入

1、目的:演示DI的能力;

2、有配置服务、日志服务，然后再开发一个邮件发送器服务。可以通过配置服务来从文件、环境变量、数据库等地方读取配置，可以通过日志服务来将程序运行过程中的日志信息写入文件、控制台、数据库等。

创建3个.NET Core类库项目，ConfigServices是配置服务的项目，LogServices是日志服务的项目，MailServices是邮件发送器的项目，然后再建1个.NET Core控制台项目MailServicesConsole来调用MailServices。MailServices项目引用ConfigServices项目和LogServices项目，而MailServicesConsole项目引用MailServices项目。

LogServices

```C#
namespace LogServices
{
    public interface ILogProvider
    {
        public void LogError(string msg);
        public void LogInfo(string msg);
    }
    public class ConsoleLogProvider : ILogProvider
    {
        public void LogError(string msg)
        {
            Console.WriteLine($"ERROR:{msg}");
        }

        public void LogInfo(string msg)
        {
            Console.WriteLine($"INFO:{msg}");
        }
    }
}
```

ConfigServices

```C#
namespace ConfigServices
{
    public interface IConfigService
    {
        public string GetValue(string name);
    }
    public class EnvVarConfigServiceImpl : IConfigService
    {
        public string GetValue(string name)
        {
            return Environment.GetEnvironmentVariable(name);
        }
    }
    public class IniFIleConfigServiceImpl : IConfigService
    {
        public string FilePath;


        public string GetValue(string name)
        {
            var kv = File.ReadAllLines(FilePath).Select(x => x.Split('='))
                .Select(strs => new { Name = strs[0], Value = strs[1] })
                .SingleOrDefault(k => k.Name == name);
            if (kv != null)
            {
                return kv.Value;
            }
            return null;

        }
    }
}
```

MailServices

```C#
namespace MailServices
{
    public interface IMailService
    {
        public void Send(string title, string content, string to);
    }
    public class MailServiceImpl : IMailService
    {
        private readonly ILogProvider _logProvider;
        private readonly IConfigService _configService;

        public MailServiceImpl(ILogProvider logProvider, IConfigService configService)
        {
            _logProvider = logProvider;
            _configService = configService;
        }

        public void Send(string title, string content, string to)
        { 
            this._logProvider.LogInfo("准备发送邮件");
            string smptServer = this._configService.GetValue("SmtpServer");
            string userName = this._configService.GetValue("UserName");
            string password = this._configService.GetValue("Password");
            Console.WriteLine($"邮件服务器地址！{smptServer}，{userName}，{password}");
            Console.WriteLine($"真发邮件了！title：{title}，content：{content}，to：{to}");
            this._logProvider.LogInfo("邮件发送完成");
        }
    }
}
```

program.cs中

```C#
// See https://aka.ms/new-console-template for more information
using ConfigServices;
using LogServices;
using MailServices;
using Microsoft.Extensions.DependencyInjection;


ServiceCollection services = new ServiceCollection();
//services.AddScoped<IConfigService, EnvVarConfigServiceImpl>();
services.AddScoped(typeof(IConfigService), x => new IniFIleConfigServiceImpl { FilePath = @"E:\.netCode\Projects\mypro\YangZack\homework\ConsoleMailSender\ConsoleMailSender\mail.ini" });
services.AddScoped<IMailService, MailServiceImpl>();
services.AddScoped<ILogProvider, ConsoleLogProvider>();
using (var scope = services.BuildServiceProvider())
{
    //第一个根上的对象只能用serviceLocator的方式注入
    var mailService = scope.GetRequiredService<IMailService>();
    mailService.Send("title", "nihao","Trump@usa.gov");
}
```

program同级目录下添加记录配置的mail.ini

```ini
SmtpServer=abc.com.cn
UserName=admin
Password=lyh
```



输出

```C#
INFO:准备发送邮件
邮件服务器地址！，Dean Hu，
真发邮件了！title：title，content：nihao，to：Trump@usa.gov
INFO:邮件发送完成

//IniFIleConfigServiceImpl的输出
INFO:准备发送邮件
邮件服务器地址！abc.com.cn，admin，lyh
真发邮件了！title：title，content：nihao，to：Trump@usa.gov
INFO:邮件发送完成
```






